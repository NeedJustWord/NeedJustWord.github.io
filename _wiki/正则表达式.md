---
layout: wiki
title: 正则表达式
---

## 元字符

### 基本元字符

| 基本元字符   | 功能                               |
| ------------ | ---------------------------------- |
| `.` (点号)   | 匹配除换行符(`\n`)外的任意单个字符 |
| `^` (脱字符) | 匹配字符串的开始位置               |
| `$` (美元符) | 匹配字符串的结束位置               |
| `\` (反斜杠) | 转义字符，使后面的字符失去特殊含义 |

### 字符类元字符

| 字符类元字符       | 功能                                            |
| ------------------ | ----------------------------------------------- |
| `[]` (方括号)      | 定义字符集合，匹配其中任意一个字符              |
| `[^]` (否定字符类) | 匹配不在方括号中的任意字符                      |
| `-` (连字符)       | 在字符类中表示范围，例如`[a-z]`匹配任意小写字母 |

### 量词元字符

| 贪婪量词元字符 | 惰性量词元字符 | 功能                          |
| -------------- | -------------- | ----------------------------- |
| `*` (星号)     | `*?`           | 匹配零次或多次，等效于`{0,}`  |
| `+` (加号)     | `+?`           | 匹配一次或多次，等效于`{1,}`  |
| `?` (问号)     | `??`           | 匹配零次或一次，等效于`{0,1}` |
| `{n}` (花括号) | `{n}?`         | 恰好匹配n次                   |
| `{n,}`         | `{n,}?`        | 至少匹配n次                   |
| `{n,m}`        | `{n,m}?`       | 匹配n到m次                    |

> 量词元字符表示其前面的子表达式要匹配多少次，其中贪婪量词匹配次数尽可能多。贪婪量词后面加上`?`就是惰性量词，惰性量词匹配次数尽可能少

### 分组和选择元字符

| 分组和选择元字符 | 功能                 |
| ---------------- | -------------------- |
| `()` (圆括号)    | 定义子表达式或捕获组 |
| `|` (竖线)       | 表示"或"关系         |

### 特殊字符类元字符

| 特殊字符类元字符 | 功能                                                        |
| ---------------- | ----------------------------------------------------------- |
| `\d`             | 匹配任意数字，等价于 `[0-9]`                                |
| `\D`             | 匹配任意非数字，等价于 `[^0-9]`                             |
| `\w`             | 匹配任意单词字符(字母、数字、下划线)，等价于 `[a-zA-Z0-9_]` |
| `\W`             | 匹配任意非单词字符，等价于 `[^a-zA-Z0-9_]`                  |
| `\s`             | 匹配任意空白字符(空格、制表符、换行符等)                    |
| `\S`             | 匹配任意非空白字符                                          |

### 边界元字符

| 边界元字符 | 功能           |
| ---------- | -------------- |
| `\b`       | 匹配单词边界   |
| `\B`       | 匹配非单词边界 |

### 其他元字符

| 其他元字符 | 功能           |
| ---------- | -------------- |
| `\n`       | 匹配换行符     |
| `\t`       | 匹配制表符     |
| `\r`       | 匹配回车符     |
| `\f`       | 匹配换页符     |
| `\v`       | 匹配垂直制表符 |



## 位置匹配

| 元字符       | 功能                 |
| ------------ | -------------------- |
| `^` (脱字符) | 匹配字符串的开始位置 |
| `$` (美元符) | 匹配字符串的结束位置 |
| `\b`         | 匹配单词边界         |
| `\B`         | 匹配非单词边界       |



## 分组和引用

### 分组

| 分组               | 功能                                          |
| ------------------ | --------------------------------------------- |
| `(pattern)`        | 捕获分组，捕获匹配的内容并分配编号（从1开始） |
| `(?:pattern)`      | 非捕获分组，分组但不捕获                      |
| `(?<name>pattern)` | 命名分组，为分组指定名称name，也是捕获分组    |

> 分组的编号按左括号`(`出现的顺序进行分配（捕获分组才有编号）

```
文本：ab
查找：((\w)(\w))
替换：$1 $2 $3
替换结果：ab a b
```

### 引用

| 引用                 | 功能                                                   |
| -------------------- | ------------------------------------------------------ |
| `\number`            | 反向引用，引用前面匹配的分组                           |
| `\k<name>`           | 命名反向引用，引用前面匹配的命名分组                   |
| `\number`或`$number` | 替换引用，在替换操作中引用分组(不同语言不一样)         |
| `${name}`            | 命名替换引用，在替换操作中引用命名分组(不同语言不一样) |



## 断言

| 断言类型     | 语法           | 别称     | 通俗解释                                |
| ------------ | -------------- | -------- | --------------------------------------- |
| 正向先行断言 | `(?=pattern)`  | 正向前瞻 | 我要找的位置，它的右边必须是pattern     |
| 负向先行断言 | `(?!pattern)`  | 负向前瞻 | 我要找的位置，它的右边一定不能是pattern |
| 正向后行断言 | `(?<=pattern)` | 正向后顾 | 我要找的位置，它的左边必须是pattern     |
| 负向后行断言 | `(?<!pattern)` | 负向后顾 | 我要找的位置，它的左边一定不能是pattern |

> 记忆方式：`=`：等于号，表肯定。`!=`：不等于号，表否定，简写成`!`。`<`：尖向左，表示找左边

### 断言的特点

1. **零宽度：**不占用匹配字符的位置
2. **条件检查：**只检查是否满足特定条件
3. **不影响匹配结果：**仅作为匹配的约束条件

### 示例

```
正向先行断言
功能：提取价格
文本：商品A价格299元，数量50；商品B价格599元，数量100
查找：\d+(?=元)
匹配结果：[299,599]
```

```
负向先行断言
功能：查找不以.js结尾的文件名
文本：index.js app.ts config.json main.js readme.md
查找：\w+\.(?!js\b)\w+
匹配结果：[app.ts,config.json,readme.md]
```

```
正向后行断言
功能：提取人民币和美元价格
文本：Price: $199, £89, ¥1200
查找：(?<=[¥$])\d+
匹配结果：[199,1200]
```

```
负向后行断言
功能：提取非负整数
文本：今天的温度是-5度，明天升温到3度，后天气温是-10度，室内温度保持22度
查找：(?<!-)\b\d+
匹配结果：[3,22]
```



## 运算符优先级

| 运算符(越前越优先)               | 表达式             |
| -------------------------------- | ------------------ |
| `\`                              | 转义符             |
| `()` `(?:)` `(?=)` `[]`          | 分组与断言         |
| `*` `+` `?` `{n}` `{n,}` `{n,m}` | 限定词(量词)       |
| `^` `$` `\任何元字符` `任何字符` | 字符序列与位置锚点 |
| `|`                              | 或运算符           |



## 平衡组

> 说明：不是所有的正则引擎都支持平衡组,本节是.Net语言的

### 预备知识

#### 命名捕获组

语法：`(?<name>pattern)`或`(?'name'pattern)`

功能：将`pattern`子表达式匹配到的内容，保存到以`name`命名的组里，以供后续引用

> 捕获组保存的是一个集合，而不只是一个元素

| 特例        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `(?<name>)` | `pattern`为空，表示匹配空字符串。因为空字符串总是隐式地存在于输入字符串中，所以此匹配始终成功 |

#### 狭义平衡组

语法：`(?<close-open>pattern)`或`(?'close-open'pattern)`

简写：`(?<-open>pattern)`或`(?'-open'pattern)`

说明：`close`是当前的组（可选，通常应用时不关注，一般都省略），`open`是以前定义的命名捕获组，`pattern`是当前组匹配的子表达式

功能：匹配成功时，删除`open`组的定义并在`close`组中保存`open`和`close`之间的内容。如果未定义`open`组，则匹配将回溯

通俗解释：平衡组类似堆栈，`open`组匹配时，入栈，`open`计数加1；`close`组匹配时，出栈，`open`计数减1，并将`open`组匹配的开始位置到`close`组匹配的结束位置之间的内容保存到`close`组。如果此前不存在匹配的`open`组，那么`close`组匹配失败

#### 断言

| 断言类型     | 语法           | 别称     | 通俗解释                                |
| ------------ | -------------- | -------- | --------------------------------------- |
| 正向先行断言 | `(?=pattern)`  | 正向前瞻 | 我要找的位置，它的右边必须是pattern     |
| 负向先行断言 | `(?!pattern)`  | 负向前瞻 | 我要找的位置，它的右边一定不能是pattern |

> 特点：零宽断言，只参与判断,不占用匹配字符

| 特例   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `(?!)` | `pattern`为空，表示我要找的位置，它的右边一定不能是空字符串。因为空字符串总是隐式地存在于输入字符串中，所以此匹配始终失败 |

#### 条件匹配表达式

语法：`(?(pattern)yes)`或`(?(pattern)yes|no)`

基于捕获组的语法：`(?(name)yes)`或`(?(name)yes|no)`或`(?(number)yes)`或`(?(number)yes|no)`

说明：`pattern`、`yes`、`no`是子表达式，`name`是命名捕获组的组名，`number`是捕获组的编号

功能：当`pattern`匹配时，执行匹配`yes`子表达式，否则执行匹配`no`子表达式（如果未提供`no`子表达式，则其等效于一个空`no`），类似三目运算符：`pattern?yes:no`

> `pattern`视为一个宽度为零的断言，所以其等效于`(?(?=pattern)yes)`或`(?(?=pattern)yes|no)`

> `pattern`和`yes`应该是有公共前缀的匹配表达式，否则匹配失败

```c#
/// <summary>
/// 当前位置右边是字符'a'，则匹配两个'\w'，否则匹配一个'\w'
/// </summary>
[TestMethod]
public void TestRegex1()
{
    string test = "abc";
    Regex reg = new Regex(@"(?(a)\w{2}|\w)");// 等效于：(?(?=a)\w{2}|\w)
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
ab
c
*/
```

| 特例            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| `(?(name)(?!))` | `name`是命名捕获组的组名，`(?!)`是`yes`子表达式。**断言特例**里分析了`(?!)`始终失败，所以整个表达式的逻辑就是判断是否存在`name`组，存在则失败。此匹配的失败表示`name`组不平衡 |

### 平衡组的通用公式

#### 分析

平衡组要考虑的问题：

1. 入栈条件是什么
2. 出栈条件是什么
3. 内容怎么匹配
4. 平衡组匹配多少次
5. 平衡组是否平衡

我们很容易知道，入栈条件、出栈条件和内容这3个是互斥的，所以这3个表达式我们可以用`|`或运算符。入栈条件可以用命名捕获组，出栈条件可以用狭义平衡组，**条件匹配表达式特例**里分析了是否平衡可以用`(?(name)(?!))`来判断，`name`是命名捕获组的组名

#### 通用公式

根据分析，我们可以得到平衡组的通用匹配公式：

`入栈匹配((?<open>入栈匹配)|(?<-open>出栈匹配)|内容匹配)匹配次数(?(open)(?!))出栈匹配`

| 公式                 | 说明                                          |
| -------------------- | --------------------------------------------- |
| `入栈匹配`           | 入栈匹配表达式                                |
| `(`                  | 分组开始，用来限定匹配次数的修饰范围          |
| `(?<open>入栈匹配)`  | 命名捕获组，遇到入栈匹配表达式，`open`计数加1 |
| `|`                  | 分支结构                                      |
| `(?<-open>出栈匹配)` | 狭义平衡组，遇到出栈匹配表达式，`open`计数减1 |
| `|`                  | 分支结构                                      |
| `内容匹配`           | 内容匹配表达式                                |
| `)匹配次数`          | 分组结束，匹配次数                            |
| `(?(open)(?!))`      | 是否平衡判断                                  |
| `出栈匹配`           | 出栈匹配表达式                                |

#### 示例

源字符串：`a+(b*(c+d))/e+f-(g/(h-i))*j`

需求：匹配成对出现的`()`中的内容

分析：入栈匹配使用`\(`，出栈匹配使用`\)`，内容匹配使用`[^()]+`，匹配次数使用`*`

公式：`\(((?<open>\()|(?<-open>\))|[^()]+)*(?(open)(?!))\)`

```c#
/// <summary>
/// 版本1
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion1()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\(((?<open>\()|(?<-open>\))|[^()]+)*(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(b*(c+d))
(g/(h-i))
*/
```

### 平衡组的优化

#### 贪婪与非贪婪模式

上一个例子已经是部分优化后的写法，算作版本1吧，它做了哪些优化呢，先来看下完全没有优化过的版本0吧

分析：入栈匹配使用`\(`，出栈匹配使用`\)`，内容匹配使用`.`，匹配次数使用`*?`

公式：`\(((?<open>\()|(?<-open>\))|.)*?(?(open)(?!))\)`

| 比较内容 | 优化前 | 优化后   |
| -------- | ------ | -------- |
| 内容匹配 | `.`    | `[^()]+` |
| 匹配次数 | `*?`   | `*`      |

```c#
/// <summary>
/// 版本0
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion0()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\(((?<open>\()|(?<-open>\))|.)*?(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(b*(c+d))
(g/(h-i))
*/
```

内容匹配使用点号`.`时，无论是使用`.`、`.*`、`.+`，还是匹配次数使用`*`，匹配的结果都是`(b*(c+d))/e+f-(g/(h-i))`，而不是`(b*(c+d))`和`(g/(h-i))`

因为这些都是贪婪模式，贪婪模式会尽可能多的匹配，直到匹配到字符串的末尾才会停止，然后进行回溯匹配。为了得到正确结果，必须使用非贪婪模式`*?`

这就类似于用`\(.+\)`去匹配`(abc)def(ghi)`一样，得到的结果是`(abc)def(ghi)`，而不是通常我们希望的`(abc)`和`(ghi)`。这时要用非贪婪模式`\(.+?\)`来得到正确的结果

贪婪模式和非贪婪模式在匹配失败时，回溯的次数基本上是一样的，效率上没有多大区别，但是在匹配成功时，贪婪模式比非贪婪模式回溯的次数要少得多，效率要高得多

对于`\(.+\)`如果既要得到正确的匹配结果，又要提高匹配效率，可以使用排除型捕获组+贪婪模式的方式，即`\([^()]+\)`，版本1即是基于此的优化

#### 分支结构

语法：`(pattern1|pattern2|pattern3)`

因为分支结构的匹配规则是从左向右尝试匹配，当左侧分支匹配成功时，就不再向右尝试。所以使用分支结构时，可以根据以下两条规则进行优化：

1. 尽量抽象出每个分支中的公共的部分，使最后的表达式中，每个分支公共部分尽可能的少，比如`(this|that)`的匹配效率是没有`th(is|at)`高的
2. 在不影响匹配结果的情况下，把出现概率高的分支放在左侧，出现概率低的分支放右侧

对于本例中的分支结构，已经没有公共部分，不符合第一条规则，再看下第二条规则，开始标记`(`和结束标记`)`出现的概率基本上是一样的，而除`(`和`)`之外的字符出现的概率是比`(`和`)`出现的概率高的，所以应该把`[^()]+`分支放在左侧

版本1由于采用了排除型捕获组，所以这三个分支没有包含关系，左右顺序对结果不会造成影响，可以调整顺序。而如果是版本0，由于`.`对`(`和`)`有包含关系，就不能调整顺序了

在版本1基础上对分支结构进行优化后，就得到版本2公式：`\(([^()]+|(?<open>\()|(?<-open>\)))*(?(open)(?!))\)`

| 比较内容 | 优化前 | 优化后 |
| -------- | ------ | ------ |
| 分支结构 | `((?<open>\()|(?<-open>\))|[^()]+)` | `([^()]+|(?<open>\()|(?<-open>\)))` |

```c#
/// <summary>
/// 版本2
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion2()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\(([^()]+|(?<open>\()|(?<-open>\)))*(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(b*(c+d))
(g/(h-i))
*/
```

#### 捕获组

这个优化涉及到两个捕获组`(?<open>\()`和`(?<-open>\))`，而在平衡组的场景中，我们只关心它是否匹配了，而对于匹配到的内容是不关心的。所以可以这样进行优化：

| 比较内容 | 优化前         | 优化后         |
| -------- | -------------- | -------------- |
| 入栈条件 | `(?<open>\()`  | `\((?<open>)`  |
| 出栈条件 | `(?<-open>\))` | `\)(?<-open>)` |

**命名捕获组特例**里分析了`(?<open>)`总是匹配成功，而匹配的内容是空的，分配的内存空间是固定的，可以有效节省资源，这在单字符嵌套结构和浅层次嵌套结构中并不明显，但是在字符序列嵌套结构和深层次嵌套结构中就比较明显了。同理`(?<-open>)`也是

由于捕获组是直接跟在开始或结束标记之后的，所以只要开始或结束标记匹配成功，命名捕获组自然就会匹配成功，对于功能是没有任何影响的

那么把标记和捕获组调整一下顺序是否可以呢？从功能上来讲，是可以的，但是匹配的流程上会有所不同，先是捕获组匹配成功，入栈，然后再匹配标记，成功则继续匹配，不成功则该分支匹配失败，进行回溯，出栈，继续尝试下一分支。这样将增加许多入栈和出栈的操作，对匹配效率是有影响的，所以这种方式并不可取

在版本2基础上对捕获组进行优化后，就得到版本3公式：`\(([^()]+|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)`

```c#
/// <summary>
/// 版本3
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion3()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\(([^()]+|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(b*(c+d))
(g/(h-i))
*/
```

#### 固化分组

在其他一些正则表达式引擎中称为原子组、非回溯子表达式、原子子表达式或一次性子表达式

语法：`(?>pattern)`

作用：匹配成功的位置，不会进行回溯

用`\([^()]+\)`去匹配`(abc)`是可以匹配成功的，因为不用回溯，相对于`\(.+?\)`这种非贪婪模式，效率上有所提升，但是对于匹配失败的情况又如何呢？

源字符串：`(abc`

正则表达式：`\([^()]+\)`

匹配中间过程这里不再详述，可以参考[NFA引擎匹配原理](http://blog.csdn.net/lxcnn/archive/2009/06/28/4304651.aspx)

当`\([^()]+`匹配到结束位置时，控制权交给`\)`，匹配失败，进行回溯，而由于前面使用了`[^()]+`这种排除型字符组，所以可供回溯的位置，不会存在可以匹配`\)`的情况，这时候的回溯是完全没有意义的，只会浪费时间，但是由于传统NFA引擎的特点，必须回溯所有可能之后才会报告匹配失败

这时可以用固化分组来进行优化，一旦占有字符，就不再释放。也就是一旦占有，就不再记录可供回溯的可能。通常是与排除型字符组或顺序否定环视一起使用的

优化后的正则表达式：`\((?>[^()]+)\)`

需要说明的一点，固化分组要作用于量词修饰的子表达式才有意义，对于`(?>abc)`，由于内容是固定的，根本就不会产生回溯，所以使用固化分组是没有意义的

对于平衡组的应用也是一样，如果分组构造中没有量词，那么使用固化分组就是没有意义的，比如版本0

在版本3基础上进行固化分组优化后，就得到版本4公式：`\((?>[^()]+|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)`

| 比较内容 | 优化前                              | 优化后                                |
| -------- | ----------------------------------- | ------------------------------------- |
| 分支结构 | `([^()]+|\((?<open>)|\)(?<-open>))` | `(?>[^()]+|\((?<open>)|\)(?<-open>))` |

```c#
/// <summary>
/// 版本4
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion4()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\((?>[^()]+|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(b*(c+d))
(g/(h-i))
*/
```

#### 小插曲

前面优化版本的内容匹配都是用的`[^()]+`，其实最开始我是用的`[^()]*`，他两在前几个版本的优化中输出结果都一样，唯独在固化分组优化中结果不同，`[^()]*`做固化分组优化算作版本5，其运行结果如下：

```c#
/// <summary>
/// 版本5
/// 匹配成对出现的`()`中的内容
/// </summary>
[TestMethod]
public void TestRegexVersion5()
{
    string test = "a+(b*(c+d))/e+f-(g/(h-i))*j";
    Regex reg = new Regex(@"\((?>[^()]*|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)");
    MatchCollection mc = reg.Matches(test);
    foreach (Match m in mc)
    {
        Console.WriteLine(m.Value);
    }
}
/*
标准输出: 
(c+d)
(h-i)
*/
```

为什么会这样呢？要分析这个问题，我们需要先知道限定符的一个知识点：

如果已找到最小捕获数，限定符`*`、`+`、`?`、`{n}`、`{n,}`、`{n,m}`及对应的惰性限定符绝不会在空匹配项后重复。 此规则会在最大可能组捕获数是无限或接近无限时，阻止限定符在空的子表达式匹配项上进入无限循环

这句话出自[限定符和空匹配项](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/quantifiers-in-regular-expressions#quantifiers-and-empty-matches)，通俗说就是匹配到0个字符后，跳出循环

接下来让我们来分析下版本5的匹配过程：

1. `\(`匹配到`(b*`的开始标记
2. 进入固化分组
   - 遇到`b*`，`[^()]*`匹配成功
   - 遇到`(`，`[^()]*`匹配0个字符，跳出循环
3. `(?(open)(?!))`判断平衡，匹配
4. 遇到`(`，`\)`匹配失败，回溯到第1步，重新开始匹配
5. `\(`匹配到`(c+d`的开始标记
6. 进入固化分组
   - 遇到`c+d`，`[^()]*`匹配成功
   - 遇到`)`，`[^()]*`匹配0个字符，跳出循环
7. `(?(open)(?!))`判断平衡，匹配
8. 遇到`)`，`\)`匹配成功
9. 匹配结束，最终成功匹配到`(c+d)`
10. 同理后面也成功匹配到`(h-i)`
11. 最终结果就是`(c+d)`和`(h-i)`

作为对比，我们也来分析下版本4`\((?>[^()]+|\((?<open>)|\)(?<-open>))*(?(open)(?!))\)`的匹配过程：

1. `\(`匹配到`(b*`的开始标记
2. 进入固化分组
   - 遇到`b*`，`[^()]+`匹配成功
   - 遇到`(`，`[^()]+`匹配失败，执行下一个分支
   - 遇到`(`，`\((?<open>)`匹配成功，入栈
   - 遇到`c+d`，`[^()]+`匹配成功
   - 遇到`)`，`[^()]+`匹配失败，执行下一个分支
   - 遇到`)`，`\((?<open>)`匹配失败，执行下一个分支
   - 遇到`)`，`\)(?<-open>)`匹配成功，出栈
   - 遇到外层`)`，`[^()]+`匹配失败，执行下一个分支
   - 遇到外层`)`，`\((?<open>)`匹配失败，执行下一个分支
   - 遇到外层`)`，由于此前不存在匹配的`open`组，`\)(?<-open>)`匹配失败
   - 至此3个分支都失败，结束循环
3. `(?(open)(?!))`判断平衡，匹配
4. 遇到外层`)`，`\)`匹配成功
5. 匹配结束，最终成功匹配到`(b*(c+d))`
6. 同理后面也成功匹配到`(g/(h-i))`
7. 最终结果就是`(b*(c+d))`和`(g/(h-i))`



## Q&A

### 常用正则表达式

| 名称     | 正则表达式                            | 功能                                        |
| -------- | ------------------------------------- | ------------------------------------------- |
| 密码强度 | `(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8,}` | 必须有大写字母、小写字母和数字，长度至少是8 |

### 正则表达式大小写转换

| 元字符 | 含义                                   |
| ------ | -------------------------------------- |
| \u     | 匹配项的第一个字符转大写，其他保持不变 |
| \U     | 匹配项转大写                           |
| \l     | 匹配项的第一个字符转小写，其他保持不变 |
| \L     | 匹配项转小写                           |

```
示例1：
文本：this is my book
查找：(\w+)
替换：\u$1
效果：This Is My Book
```

```
示例2：
文本：this is my book
查找：(\w+)
替换：\U$1
效果：THIS IS MY BOOK
```

```
示例2：首字母大写，其余小写
文本：THIS IS MY BOOK
查找：(\w)(\w+)
替换：\U$1\L$2
效果：This Is My Book
```



## 参考资料

1. [正则表达式大小写转换](https://blog.csdn.net/small__snail__5/article/details/88946566)
2. [正则表达式中\L、\Q和\E的用法总结](https://blog.csdn.net/gsjthxy/article/details/107854460)
3. [正则表达式 - 教程](https://www.runoob.com/regexp/regexp-tutorial.html)
4. [正则表达式语言 - 快速参考](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference)
5. [.NET正则平衡组](https://www.cnblogs.com/daxiongblog/p/10459309.html)

